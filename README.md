# Prosjekt 2 - Dokumentasjon

## Krav til funksjonalitet
Applikasjonen vår møter alle krav som har blitt satt for prosjektet. Utformingen involverer en tab som lar brukeren bytte mellom forskjellige kombinasjoner med visuelle og auditive elementer. Et essensielt designvalg vi har gjort er å gi brukeren muligheten til å opprette nye tabs om dette er ønsket. Etter gjennomtanke, syntes vi dette var en logisk funksjonalitet å innføre, da det er svært mange kombinasjoner av valg brukeren kan gjøre i hver tab. Når brukeren har markert en tab, vil vedkommende kunne se at tidligere valg er lagret og at dette er reflektert på de dynamiske elementene på skjermen.

Alle valg som brukeren gjør for å endre på elementene på siden, velges med en komponent vi designet kalt MediaPicker. Dette er en liste med checkboxes som representerer kategorier for ulike temaer. Når brukeren velger en kategori, vil et tilfeldig element fra denne kategorien vises og caches av applikasjonen. Kombinasjonen av disse valgene ligger deretter lagret i taben som brukes, slik at brukeren kan finne frem til dem igjen. Det finnes tre kategorier av SVG-bilder, tre kategorier av tekst og tre kategorier av lyd, alle med flere ulike relevante filer tilgjengelige.

## Krav til teknologi

### React
For å utvikle vår applikasjon, har vi benyttet React med JSX til å implementere komponenter til interaktiv UI. Dette har blitt gjort ved hjelp av JavaScript ES6 med muligheten til å utvikle et komponent-basert brukergrensesnitt. En komponent i React er et innkapslet element som bevarer sin egen tilstand og kan bli bygget opp fra bunnen av ved hjelp av andre, “mindre” komponenter. Vi har designet strukturen vår slik at enhver komponent er bygget opp av mindre komponenter, med såkalte “parts” som nederste byggekloss. Komponenter og parts er strukturert i hver sine mapper og er laget fra bunnen av uten eksterne biblioteker eller komponenter. Kun standard React og CSS er benyttet til design av komponentene.

### Ajax
For å hente ut ressursfiler for lokal benyttelse på brukerens enhet, har vi brukt et innebygget grensesnitt for Ajax som benytter funksjonen window.fetch i React. Vi laget egne funksjoner for kall av filer, da vi ønsket å hindre unødvendig gjentagelse av kode. Filene ble cachet i en egen state i en komponent etter uthenting, slik at brukeren ikke trengte å laste dem inn på nytt dersom vedkommende laget en ny tab med innhold. Vi vurderte denne implementasjonen opp mot sessionStorage, men fant kilder som viste til at vår implementasjon var mer ressursbesparende. Lydfilene ble som vanlig lastet inn med et standard HTML <audio>-tag, mens bildene var på vektorformat.
  
### Responsive Web Design
For å passe på at applikasjonen fungerte både visuelt og interaktivt konsekvent på enhver enhet, gjorde vi alle aspekter ved nettsiden responsive kun ved hjelp av standard CSS. Dette gjaldt spesielt mobil vs desktop, da vi ønsket å ha forskjellig design på nettsiden gitt størrelsen på skjermen grunnet nødvendige forskjeller mellom desktop og mobile enheter. Det ble benyttet media queries for å sikre responsivitet. Vi kan for eksempel se at teksten havner under bildet på en mobilskjerm og at bildet skalerer sin størrelse om browservinduet endrer seg på desktop. Responsiviteten er testet underveis i utviklingen, som beskrives mer detaljert i seksjonen under om testing.

### Utvikling
Under utviklingen av prosjektet har vi benyttet et repository med samarbeidsverktøyet Github for å kunne koordinere kode og prosjektstruktur. Her opprettet vi et “project”, som hadde en kobling opp mot prosjektets issues. Disse kunne automatisk oppdateres på et taskboard med en status for hver enkelt task. Dette ga oss god oversikt over hva hver enkelt utvikler jobbet med og hvilke commits som var tilhørende et spesifikt issue. Om en commit markerte et issue som gjennomført, ble dette reflektert automatisk på taskboardet.

Vi passet også på å ha god kodestruktur, hensiktsmessig inndeling av komponenter og kommentarer på viktige funksjoner i koden. Slik kunne vi alltid komme tilbake til koden senere om nødvendig. Siden React i stor grad baserer seg på gjenbruk av kode og komponenter, så er det viktig å kunne forstå kode som kan være til hjelp under utvikling av andre funksjoner. Derfor har vi benyttet eksempler fra React sine egne eksempelprosjekter og kodesnutter for å få en idé om hva som er best practice angående mappestruktur og utforming av kode.

## Testing
Gjennomgående testing av applikasjonen er viktig for å kunne sikre konsekvent funksjonalitet og responsivitet på forskjellige brukerenheter. Selv om applikasjonen tilsynelatende ser ut til å skalere bra under utvikling, bør man teste mer planmessig slik at edge-cases ikke fører til uforutsette problemer. Vi vurderte ulike testverktøy for å løse disse problemene. Blant annet var Cypress et godt alternativ. Til slutt valgte vi likevel ikke å benytte oss av dette, da det for våre bruksområder behøvde en større implementasjon enn det var verdt.

Vi har gjennomgående testet ulike skjermstørrelser i Google Chrome, Firefox og Edge. Google Chrome har også støtte for å simulere skjermstørrelser til ulike enheter, samt selvbestemte størrelser om dette er ønsket. For eksempel kunne vi sammenligne mobilstørrelser med store skjermer for desktop på en rask og effektiv måte. Likevel følte vi at det var nødvendig å teste mobilenheter på ekte mobiler slik at vi var sikre på at responsiviteten fungerte som det skulle. Dette fokuserte vi mer på mot slutten av utviklingsperioden.

Til slutt har vi kjørt applikasjonen gjennom Audits i Google Chrome for å teste generell ytelse og brukervennlighet. Dette hjelper for å finne og løse enkle problemer som vi kunne ha oversett i første omgang. For eksempel ville problemer knyttet til kodestruktur eller definisjoner påvirke brukervennlighet for de som har tilpasset nettleseren sin med visuelle temaer, endringer eller liknende. Ved å teste med Audits, kunne vi finne ut hva som manglet og hva som var best practice under utformingen av siden. Dessuten tester Audits ytelse på hele nettsiden, som gjør at vi stadig kunne forbedre oppstarten og bruken av applikasjonen. Vi fant for eksempel ut at å benytte window.fetch til å hente ut bilder for visning i applikasjonen førte til betraktelig dårligere ytelse, da det ville vært enklere å importere ressursene direkte med React. Vi valgte likevel ikke å endre på denne implementasjonen, da bruk av AJAX for henting av SVG-bildene var et krav for prosjektet.
